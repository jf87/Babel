%!TEX root=../main.tex

% Notes Whiteboard:
%
% 4. Design/Architecture
% --> match design goals here!
%
% 4.1 Overall Architecture
% -
% -
% -
%
% 4.2 Algorithm
% 4.3 Schema/Types Library
% 4.4 User Part

\section{System Implementation} % (fold)
\label{sec:system_implementation}


\subsection{BMS Simulation} % (fold)
\label{sub:bms_simulation}
Here we describe our fake BMS.

\fixme{i don't think simulation is should be in the paper..}
% subsection bms_simulation (end)


\subsection{YueLao Server} % (fold)
\label{sub:babel_server}
Here we describe how our application that runs on the server works.

% subsection babel_server (end)

\subsection{Pattern Matching} % (fold)
\label{sub:pattern_matching}

An actuator is matched to a location by (i) a pattern of setpoint changes that is instantiated by a user of YueLao and possibly (ii) sensor readings at that location.
Setpoint changes are, e.g., a user switching a light in a specific pattern or a user setting a heating setpoint for a thermostat.
Such a pattern is translated to the user in the following form (using the example of a binary light switch):

\begin{enumerate}

  \item Turn the light off in the next 5s.

  \item Turn the light on in the next 5s.

  \item Turn the light off in the next 5s.

\end{enumerate}

Sensor readings are, e.g., a user reading the current temperature reading of a thermostat display.

For both cases, setpoint changes and setpoint readings,  our algorithm is then matching the expected pattern by querying the BMS.
The basic working of YueLao's algorithm is depicted in Algorithm~\ref{alg1}.
Its goal is to seperate other, unpredictable setpoint changes that might happen durring a matching process from the actual matching process.
We achieve this by continuously querying the BMS points to get their current state. If we find a match with the sequence of the type the user is matching, we increment a counter for the specific setpoint. This assures basically that we match a sequence of setpoint changes in order.
The querying of the BMS is done for a timeperiod that is defined by the sum of the single sequence operations plus a time constant for tha latency of the BMS.

\fixme{Discuss algorithm with Kaifei and fix it. Probably should continue querying even found==true. We might have false positives. If after some time we find then e.g., 3 setpoints that match, we can send a request back to the user to do the sequence again or do a modified one.}
 \begin{algorithm}
 \caption{Pattern Matching}
 \label{alg1}
 \begin{algorithmic}
 \STATE $found \leftarrow False$
 \STATE $matches \leftarrow 0$
 \STATE $latency \leftarrow 30$
 \STATE $t_{total} \leftarrow 0$
 \STATE $seq \leftarrow pattern~for~type$
 \FOR{t in seq.t}
 \STATE $t_{total} \leftarrow t_{total} + t$
 \ENDFOR
 \STATE $t_{total} \leftarrow t_{total} + latency$
 \STATE $t_{start} \leftarrow time.Now()$
 \WHILE{$!found~\AND~(time.Now()-t_start < t_{total})$}
 \FOR{s in setpoints}
   \IF{$s.value$ == seq.value[s.seq]}
     \IF {$s.seq == len(seq)$}
       \STATE $found \leftarrow True$
     \ENDIF
     \STATE $s.seq \leftarrow s.seq +1$
   \ENDIF
\ENDFOR
    \STATE {$time.Sleep(1000)$}
 \ENDWHILE
 \end{algorithmic}
 \end{algorithm}
% subsection pattern_matching (end)


\subsection{Configuration App} % (fold)
\label{sub:configuration_app}
Here we describe the client application on the Android device.
% subsection configuration_app (end)

% section system_implementation (end)